#include "luabind.hpp"

namespace lua_bind {

SignalManagerWrapper ResourcesWrapper::GetSignalManager() { return res_.Get<SignalManager>(); }

#define BIND_QUERIER_FUNC(name) \
querier["Query" #name] = &QuerierWrapper::Query ## name; \
querier["Has" #name] = &QuerierWrapper::Has ## name; \
querier["Get" #name] = &QuerierWrapper::Get ## name;

using ui::UIEventListener;
using ui::EventType;

#define BindHandle(name) \
{ \
    sol::usertype<name> handle = script.lua.new_usertype<name>(#name); \
    handle["IsValid"] = &::name::IsValid; \
}

#define BindEventReader(name) \
{ \
    sol::usertype<name> reader = script.lua.new_usertype<name>(#name); \
    reader["Has"] = &name::Has; \
    reader["Read"] = &name::Read; \
    reader["Clear"] = &name::Clear; \
}

#define BindEventWriter(name, event_type) \
{ \
    sol::usertype<name> writer = script.lua.new_usertype<name>(#name); \
    writer["Write"] = &name::Write; \
    writer["WriteImmediate"] = sol::overload(static_cast<void(name::*)(const event_type&)>(&name::WriteImmediate)); \
}

#define BindHeapMatrix(type, name) \
{ \
    using mtype = math::HeapMatrix<type>; \
    sol::usertype<mtype> matrix= script.lua.new_usertype<mtype>(#name); \
    matrix["Fill"] = &mtype::Fill; \
    matrix["Width"] = &mtype::Width; \
    matrix["Height"] = &mtype::Height; \
    matrix["Get"] = sol::overload(static_cast<type&(mtype::*)(int, int)>(&mtype::Get), \
                                static_cast<const type&(mtype::*)(int, int) const>(&mtype::Get)); \
    matrix["Set"] = sol::overload(static_cast<void(mtype::*)(int, int, const type &)>(&mtype::Set)); \
    matrix["IsInRange"] = &mtype::IsInRange; \
}

}

using namespace lua_bind;

void BindLua(LuaScript& script) {
    // some special class you should bind them handly
    sol::usertype<SignalManagerWrapper> signalMgr =
        script.lua.new_usertype<SignalManagerWrapper>("SignalManager");
    signalMgr["Raise"] = &SignalManagerWrapper::Raise;
    signalMgr["Remove"] = &SignalManagerWrapper::Remove;
    signalMgr["Regist"] = &SignalManagerWrapper::Regist;

    BindHeapMatrix(MapTile, HeapMatrixMapTile)
    BindHeapMatrix(ecs::Entity, HeapMatrixEntity)

    BindEventReader(LuaEventContextReader)
    BindEventWriter(LuaEventContextWriter, LuaEventContext)

    BindHandle(FontHandle)
    BindHandle(ImageHandle)
    BindHandle(TimerHandle)

    sol::usertype<MouseButton> mouseButton =
        script.lua.new_usertype<MouseButton>("MouseButton");
    mouseButton["IsPressed"] = &MouseButton::IsPressed;
    mouseButton["IsReleased"] = &MouseButton::IsReleased;
    mouseButton["IsPressing"] = &MouseButton::IsPressing;
    mouseButton["IsReleasing"] = &MouseButton::IsReleasing;

    sol::usertype<KeyButton> keyButton =
        script.lua.new_usertype<KeyButton>("KeyButton");
    keyButton["IsPressed"] = &KeyButton::IsPressed;
    keyButton["IsReleased"] = &KeyButton::IsReleased;
    keyButton["IsPressing"] = &KeyButton::IsPressing;
    keyButton["IsReleasing"] = &KeyButton::IsReleasing;

    script.lua.new_usertype<ecs::Entity>("Entity");

    // auto-generate bind codes

    ##BIND_CONTENT##

    resources["GetSignalManager"] = &ResourcesWrapper::GetSignalManager;
}

