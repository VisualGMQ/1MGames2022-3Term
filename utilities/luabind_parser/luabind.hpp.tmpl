#pragma once

#include "app/ui.hpp"
#include "core/pch.hpp"
#include "app/lua.hpp"
#include "app/transform.hpp"
#include "app/scene.hpp"
#include "app/sprite.hpp"
#include "app/font.hpp"
#include "app/ui.hpp"
#include "app/script.hpp"
#include "app/timer.hpp"
#include "game/types.hpp"
#include "game/monster.hpp"
#include "game/config.hpp"
#include "game/map.hpp"
#include "game/game.hpp"

namespace lua_bind {

using std::function;

#define IMPL_QUERY_FUNC(name, type) \
std::vector<ecs::Entity> Query ## name() { \
    return querier_.Query<type>(); \
}

#define IMPL_HAS_FUNC(name, type) \
bool Has ## name(ecs::Entity entity) { \
    return querier_.Has<type>(entity); \
}

#define IMPL_GET_FUNC(name, type) \
auto& Get ## name(ecs::Entity entity) { \
    return querier_.Get<type>(entity); \
} 

#define IMPL_FUNC(name, type) \
IMPL_QUERY_FUNC(name, type) \
IMPL_HAS_FUNC(name, type) \
IMPL_GET_FUNC(name, type) \

class SignalManagerWrapper;

// FIXME: elem is lvalue, but `AddComponent` need rvalue, and sol bind lua can't
// use rvalue. So we use lvalue here temporary
#define IMPL_ADD_FUNC(type) \
void Add(ecs::Entity entity, type elem) { \
    cmds_.AddComponent<type>(entity, std::move(elem)); \
}

using ecs::Commands;
using ecs::Events;
using ecs::Querier;
using ecs::Resources;

struct CommandsWrapper final {
public:
    friend class SignalManagerWrapper;

    CommandsWrapper(ecs::Commands& cmds): cmds_(cmds) {}

    ecs::Entity Spawn() { return cmds_.SpawnAndReturn(); }
    void DestroyEntity(ecs::Entity entity) { cmds_.DestroyEntity(entity); }

    ##COMMANDS_WRAPPER_INSERT_TAG##

    auto& Raw() {
        return cmds_;
    }

private:
    ecs::Commands& cmds_;
};

using LuaEventContextReader = ecs::EventReader<::LuaEventContext>;
using LuaEventContextWriter = ecs::EventWriter<::LuaEventContext>;

class EventsWrapper final {
public:
    friend class SignalManagerWrapper;

    EventsWrapper(ecs::Events& events): events_(events) {}

    LuaEventContextReader ReadEventContext() {
        return events_.Reader<::LuaEventContext>();
    }

    LuaEventContextWriter WriteEventContext() {
        return events_.Writer<::LuaEventContext>();
    }

    auto& Raw() {
        return events_;
    }

private:
    ecs::Events& events_;
};


class QuerierWrapper final {
public:
    friend class SignalManagerWrapper;

    QuerierWrapper(ecs::Querier querier): querier_(querier) {}

    ##QUERIER_WRAPPER_INSERT_TAG##

    auto Raw() {
        return querier_;
    }

private:
    ecs::Querier querier_;
};

#undef IMPL_QUERY_FUNC
#undef IMPL_HAS_FUNC
#undef IMPL_GET_FUNC
#undef IMPL_FUNC

class ResourcesWrapper final {
public:
    friend class SignalManagerWrapper;

    ResourcesWrapper(ecs::Resources res): res_(res) {}

    SignalManagerWrapper GetSignalManager();

    ##RESOURCE_WRAPPER_INSERT_TAG##

    auto Raw() {
        return res_;
    }

private:
    ecs::Resources res_;
};

class SignalManagerWrapper final {
public:
    using CallbackFunc = std::function<void(CommandsWrapper, QuerierWrapper, ResourcesWrapper, EventsWrapper, sol::object&)>;

    SignalManagerWrapper(SignalManager& raw): raw_(raw) {}

    void Remove(uint32_t name) {
        raw_.Remove(name);
    }

    void Raise(uint32_t name, CommandsWrapper cmds, QuerierWrapper querier, ResourcesWrapper res, EventsWrapper events, sol::object* param) {
        raw_.Raise(name, cmds.cmds_, querier.querier_, res.res_, events.events_, (void*)param);
    }

    void Regist(uint32_t name, CallbackFunc func) {
        raw_.Regist(name, [=](ecs::Commands& cmds, ecs::Querier querier,
                              ecs::Resources res, ecs::Events& events, void* param) {
            func(CommandsWrapper(cmds), QuerierWrapper(querier),
                 ResourcesWrapper(res), EventsWrapper(events), *((sol::object*)param));
        });
    }

private:
    ::SignalManager& raw_;
};


void BindLua(LuaScript&);

}